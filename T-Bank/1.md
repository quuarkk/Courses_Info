## Общие принципы использования алгоритмов

Прежде чем погрузиться в конкретные задачи, давай разберем общие шаги, которые помогут тебе подходить к любой задаче системно:

1. **Анализ условий**:
   - Что дано? Тип данных (числа, строки), ограничения (размер \( n \), диапазон значений), особенности (отсортированность, уникальность).
   - Что нужно найти? Точное значение, количество, оптимальный вариант.
   - Ищи подсказки: отсортированные данные часто указывают на бинарный поиск, а подсчет пар — на сортировку или структуры данных.

2. **Выбор алгоритма**:
   - Отсортированные данные → бинарный поиск.
   - Минимум/максимум → бинарный поиск по ответу.
   - Сортировка → слияние, быстрая сортировка.
   - Подсчет характеристик (инверсии, пары) → модификация сортировки.

3. **Оптимизация**:
   - Временные ограничения: для \( n \leq 10^5 \) подойдет \( O(n \log n) \), для \( n \leq 10^6 \) — \( O(n) \).
   - Используй свойства: монотонность, частоты, уникальность.

4. **Модификация**:
   - Адаптируй алгоритм: добавь подсчет, измени условия, используй другие структуры (массивы, деревья).

Теперь перейдем к задачам.

---

## Задача A: Двоичный поиск

### Условие
Дан отсортированный массив, нужно проверить, есть ли в нем элемент \( x \).

### Решение
```python
def binary_search(arr, x):
    left = 0                # левая граница поиска
    right = len(arr) - 1    # правая граница поиска
    while left <= right:    # пока интервал не пустой
        mid = (left + right) // 2  # средний элемент
        if arr[mid] == x:      # если нашли x
            return "YES"
        elif arr[mid] < x:     # если средний меньше x
            left = mid + 1     # ищем в правой половине
        else:                  # если средний больше x
            right = mid - 1    # ищем в левой половине
    return "NO"                # элемент не найден
```

### Принципы и логика
- **Идея**: Бинарный поиск работает на отсортированном массиве, уменьшая область поиска вдвое на каждом шаге.
- **Ходы**:
  1. Инициализируем границы: \( left = 0 \), \( right = n-1 \).
  2. Пока \( left <= right \) (интервал не пуст):
     - Находим середину \( mid \).
     - Сравниваем \( arr[mid] \) с \( x \):
       - Если равны, нашли элемент.
       - Если \( arr[mid] < x \), искомое справа → \( left = mid + 1 \).
       - Если \( arr[mid] > x \), искомое слева → \( right = mid - 1 \).
  3. Если цикл завершился, элемента нет.

- **Почему работает**: Отсортированность гарантирует, что если \( arr[mid] < x \), то все элементы слева тоже меньше \( x \), и наоборот.

- **Сложность**: \( O(\log n) \), так как размер интервала делится пополам.

### Модификации
- **Поиск первого вхождения**: После нахождения \( x \) продолжай сужать \( right \), пока \( mid \) не станет минимальным индексом с \( x \).
- **Нестрогий поиск**: Измени условие на \( arr[mid] <= x \) для поиска ближайшего меньшего.
- **Индекс вместо "YES"**: Верни \( mid \) вместо строки.

### Когда использовать
Когда данные отсортированы, и нужен быстрый поиск.

---

## Задача B: Рядом

### Условие
Найти ближайший элемент к \( x \) в отсортированном массиве.

### Решение
```python
def find_closest(arr, x):
    n = len(arr)
    if x <= arr[0]:         # если x меньше минимального
        return arr[0]
    if x >= arr[n-1]:       # если x больше максимального
        return arr[n-1]
    left = 0                # левая граница
    right = n - 1           # правая граница
    while left <= right:    # пока интервал не пуст
        mid = (left + right) // 2
        if arr[mid] == x:   # если нашли точное совпадение
            return arr[mid]
        elif arr[mid] < x:  # если средний меньше
            left = mid + 1
        else:               # если средний больше
            right = mid - 1
    # вышли из цикла, сравниваем соседей
    left_val = arr[right]   # значение слева от x
    right_val = arr[left]   # значение справа от x
    if abs(x - left_val) <= abs(x - right_val):
        return left_val     # ближе левый
    return right_val        # ближе правый
```

### Принципы и логика
- **Идея**: Используем бинарный поиск, чтобы найти позицию вставки \( x \), затем сравниваем соседние элементы.
- **Ходы**:
  1. Проверяем краевые случаи: если \( x \) вне массива, берем ближайший конец.
  2. Ищем позицию с помощью бинарного поиска:
     - Когда \( left > right \), \( right \) указывает на элемент слева от \( x \), а \( left \) — справа.
  3. Сравниваем расстояния до \( arr[right] \) и \( arr[left] \), выбираем меньшее.

- **Почему работает**: Отсортированность гарантирует, что после поиска \( arr[right] < x < arr[left] \).

- **Сложность**: \( O(\log n) \).

### Модификации
- **Несколько ближайших**: Верни оба значения \( left_val \) и \( right_val \).
- **Учет весов**: Сравнивай \( |x - arr[i]| \cdot weight[i] \).
- **Только меньшие элементы**: Верни \( left_val \) без сравнения.

### Когда использовать
Отсортированные данные, поиск приблизительного значения.

---

## Как модифицировать алгоритмы

1. **Бинарный поиск**:
   - Границы: Сохраняй позиции.
   - Вещественные числа: Используй \( eps \).
   - Интерактивность: Замени сравнение на запросы.

2. **Сортировка слиянием**:
   - Добавь подсчет в \( merge \).
   - Измени условие слияния.

3. **Жадные алгоритмы**:
   - Определи критерий (длина, порядок).
   - Учти ограничения.

4. **Анализ сложности**:
   - Построй худший случай.

---

## Универсальные ходы
1. **Разделяй и властвуй**: Дели на подзадачи.
2. **Свойства**: Используй отсортированность, монотонность.
3. **Симуляция**: Моделируй процесс.
4. **Динамика**: Обновляй состояние.

Теперь ты можешь применять эти подходы и адаптировать алгоритмы под любые задачи!
