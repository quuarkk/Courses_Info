Давайте разберем конспект лекции шаг за шагом. Мы начнем с базовых концепций, перейдем к примерам кода на Python и научимся применять эти знания на практике.

---

### 1. **Зет-функция (Z-функция)**
#### **Что это?**
Z-функция для строки — это массив, где каждый элемент `Z[i]` показывает длину наибольшего подстроки, начинающейся с позиции `i`, которая совпадает с префиксом (началом) исходной строки.

**Пример:**  
Для строки `"ABABA"`:
- `Z[0] = 5` (вся строка совпадает с префиксом).
- `Z[1] = 0` (подстрока `"BABA"` не совпадает с префиксом `"A"`).
- `Z[2] = 3` (подстрока `"ABA"` совпадает с префиксом `"ABA"`).

---

#### **Как работает алгоритм?**
Используем два указателя `L` и `R`, которые обозначают текущий самый правый отрезок совпадения с префиксом.

**Алгоритм:**
1. Инициализируем `L = 0`, `R = 0`, `n = len(s)`.
2. Для каждого `i` от 1 до `n-1`:
   - Если `i > R`, расширяем `R` вправо, пока символы совпадают.
   - Если `i <= R`, используем ранее вычисленные значения для ускорения.

**Код на Python:**
```python
def z_function(s):
    n = len(s)
    Z = [0] * n
    L, R = 0, 0
    for i in range(1, n):
        if i <= R:
            Z[i] = min(R - i + 1, Z[i - L])
        while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:
            Z[i] += 1
        if i + Z[i] - 1 > R:
            L, R = i, i + Z[i] - 1
    Z[0] = n  # По определению
    return Z

# Пример использования:
s = "ABABA"
print(z_function(s))  # [5, 0, 3, 0, 1]
```

---

### 2. **Хэширование строк**
#### **Что такое хэш-функция?**
Хэш-функция преобразует строку в число, которое можно использовать для быстрого сравнения строк.

**Пример:**  
Хэш строки можно вычислить как полином:
```
hash(s) = (s[0] * P^(n-1) + s[1] * P^(n-2) + ... + s[n-1]) % MOD
```
Где `P` — основание (например, 31), `MOD` — большое простое число (например, 10^9 + 7).

**Код на Python:**
```python
def compute_hash(s, P=31, MOD=10**9 + 7):
    hash_val = 0
    power = 1
    for char in s:
        hash_val = (hash_val + (ord(char) - ord('a') + 1) * power) % MOD
        power = (power * P) % MOD
    return hash_val

s1 = "abc"
s2 = "abc"
print(compute_hash(s1))  # 2946
print(compute_hash(s2))  # 2946 (совпадает)
```

---

### 3. **Поиск подстрок с хэшами**
#### **Префиксные хэши**
Можно предварительно вычислить хэши для всех префиксов строки, чтобы быстро сравнивать подстроки.

**Код:**
```python
def prefix_hashes(s, P=31, MOD=10**9 + 7):
    n = len(s)
    prefix = [0] * (n + 1)
    power = [1] * (n + 1)
    for i in range(n):
        prefix[i+1] = (prefix[i] + (ord(s[i]) - ord('a') + 1) * power[i]) % MOD
        power[i+1] = (power[i] * P) % MOD
    return prefix, power

# Проверка подстроки s[a..b] и s[c..d]
def get_hash(prefix, power, a, b, MOD):
    return (prefix[b+1] - prefix[a]) * power[len(prefix) - a - 1] % MOD

s = "abacaba"
prefix, power = prefix_hashes(s)
hash_ab = get_hash(prefix, power, 0, 1, 10**9 + 7)  # "ab"
hash_ac = get_hash(prefix, power, 2, 3, 10**9 + 7)  # "ac"
print(hash_ab != hash_ac)  # True
```

---

### 4. **Хэш-таблицы**
#### **Что это?**
Структура данных, которая хранит пары ключ-значение, используя хэш-функцию для быстрого доступа.

**Реализация на Python (упрощенная):**
```python
class HashTable:
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]  # Метод цепочек

    def _hash(self, key):
        return hash(key) % self.size

    def insert(self, key, value):
        h = self._hash(key)
        for pair in self.table[h]:
            if pair[0] == key:
                pair[1] = value  # Обновить значение
                return
        self.table[h].append([key, value])

    def get(self, key):
        h = self._hash(key)
        for pair in self.table[h]:
            if pair[0] == key:
                return pair[1]
        return None

# Пример использования:
ht = HashTable()
ht.insert("apple", 5)
ht.insert("banana", 7)
print(ht.get("apple"))  # 5
```

---

### 5. **Алгоритм Кнута-Морриса-Пратта (КМП)**
#### **Связь с Z-функцией**
КМП использует префикс-функцию, которая похожа на Z-функцию. Префикс-функция для позиции `i` — это длина наибольшего собственного префикса, который также является суффиксом.

**Код префикс-функции:**
```python
def prefix_function(s):
    n = len(s)
    pi = [0] * n
    for i in range(1, n):
        j = pi[i-1]
        while j > 0 and s[i] != s[j]:
            j = pi[j-1]
        if s[i] == s[j]:
            j += 1
        pi[i] = j
    return pi

s = "abacaba"
print(prefix_function(s))  # [0, 0, 1, 0, 1, 2, 3]
```

---

### **Как думать?**
1. **Разбивайте задачу на части.** Например, для поиска подстроки:
   - Сначала вычисляем Z-функцию или префикс-функцию.
   - Используем их для оптимизации сравнений.
2. **Тестируйте на примерах.** Всегда проверяйте код на простых строках вроде `"ABABA"`.
3. **Понимайте, зачем нужны структуры данных.** Хэш-таблицы ускоряют поиск, а Z-функция — сравнение подстрок.

---

### **Практика**
1. Реализуйте Z-функцию для строки `"aaaaa"`. Что получится?
2. Напишите хэш-функцию, которая учитывает порядок символов.
3. Создайте хэш-таблицу для подсчета частоты слов в тексте.

Если что-то осталось непонятным, задавайте вопросы!
