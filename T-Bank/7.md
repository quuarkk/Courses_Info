Отлично! Давайте разберем динамическое программирование (ДП) шаг за шагом на примерах из лекции. Каждый пример будет сопровождаться кодом на Python и подробным объяснением.

---

### 1. Числа Фибоначчи: от рекурсии к ДП
**Проблема:** Рекурсивный расчет чисел Фибоначчи имеет экспоненциальную сложность из-за повторных вычислений.  
**Решение:** Использовать массив для хранения уже вычисленных значений (мемоизация).

#### Код:
```python
def fibonacci(n):
    dp = [0] * (n + 1)
    dp[0], dp[1] = 0, 1  # Базовые случаи
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]  # Формула пересчета
    return dp[n]

print(fibonacci(10))  # 55
```

**Объяснение:**
- `dp[i]` хранит i-е число Фибоначчи.
- Базовые случаи: `F(0) = 0`, `F(1) = 1`.
- Каждое следующее число — сумма двух предыдущих.
- **Сложность:** O(n) вместо O(2^n) у рекурсии.

---

### 2. Ближайшая единица слева
**Проблема:** Для каждого элемента массива найти индекс ближайшей единицы слева.  
**Решение:** Линейный проход с запоминанием последней позиции единицы.

#### Код:
```python
def nearest_one_left(arr):
    n = len(arr)
    dp = [-1] * n  # -1 означает, что единицы слева нет
    last_one = -1  # Индекс последней встреченной единицы

    for i in range(n):
        if arr[i] == 1:
            last_one = i
            dp[i] = i  # Сама единица — ближайшая
        else:
            dp[i] = last_one  # Берем значение из предыдущего элемента
    return dp

arr = [1, 0, 1, 0, 0, 1, 0]
print(nearest_one_left(arr))  # [0, 0, 2, 2, 2, 5, 5]
```

**Объяснение:**
- Если текущий элемент — `1`, обновляем `last_one`.
- Если `0`, берем значение из предыдущей позиции.

---

### 3. Черепашка: максимальная сумма в матрице
**Проблема:** Черепашка движется из левого верхнего угла в правый нижний, собирая монеты. Найти путь с максимальной суммой.  
**Решение:** Заполнить матрицу, где `dp[i][j]` — максимальная сумма на пути до клетки `(i, j)`.

#### Код:
```python
def max_coins(grid):
    rows = len(grid)
    cols = len(grid[0])
    dp = [[0] * cols for _ in range(rows)]
    
    # Инициализация первой строки и первого столбца
    dp[0][0] = grid[0][0]
    for i in range(1, rows):
        dp[i][0] = dp[i-1][0] + grid[i][0]
    for j in range(1, cols):
        dp[0][j] = dp[0][j-1] + grid[0][j]
    
    # Заполнение остальных клеток
    for i in range(1, rows):
        for j in range(1, cols):
            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]
    
    return dp[-1][-1]

grid = [
    [5, 3, 2],
    [1, 4, 7],
    [2, 0, 8]
]
print(max_coins(grid))  # 5 → 4 → 7 → 8 = 24
```

**Объяснение:**
- Базовые случаи: первая строка и первый столбец накапливают сумму.
- Для остальных клеток берем максимум из верхней или левой клетки.

---

### 4. Задача о рюкзаке
**Проблема:** Выбрать предметы с максимальной стоимостью, не превышая вес рюкзака.  
**Решение:** Двумерный массив `dp[i][w]` — максимальная стоимость для первых `i` предметов и веса `w`.

#### Код:
```python
def knapsack(weights, values, capacity):
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(1, capacity + 1):
            if weights[i-1] <= w:
                # Выбираем: взять текущий предмет или нет
                dp[i][w] = max(dp[i-1][w], values[i-1] + dp[i-1][w - weights[i-1]])
            else:
                dp[i][w] = dp[i-1][w]
    return dp[n][capacity]

weights = [3, 2, 5, 3]
values = [4, 3, 5, 6]
capacity = 10
print(knapsack(weights, values, capacity))  # 14 (3+2+3 → 4+3+6)
```

**Объяснение:**
- Если вес предмета ≤ текущего веса, выбираем максимум из:
  - Не взять предмет (`dp[i-1][w]`).
  - Взять предмет (`values[i-1] + dp[i-1][w - вес]`).
- **Оптимизация памяти:** Можно использовать одномерный массив, обновляя его справа налево.

---

### Как думать в ДП:
1. **Определите состояние:** Что хранится в `dp[i]` или `dp[i][j]`?
2. **Базовые случаи:** Какие начальные значения?
3. **Формула перехода:** Как новое состояние зависит от предыдущих?
4. **Порядок вычислений:** В каком порядке заполнять массив?
5. **Результат:** Где находится ответ?

---

### Пример: Восстановление пути в задаче о черепашке
```python
def get_path(dp):
    rows = len(dp)
    cols = len(dp[0])
    path = []
    i, j = rows-1, cols-1
    
    while i > 0 or j > 0:
        path.append((i, j))
        if i == 0:
            j -= 1
        elif j == 0:
            i -= 1
        else:
            if dp[i-1][j] > dp[i][j-1]:
                i -= 1
            else:
                j -= 1
    path.append((0, 0))
    return path[::-1]

# Для grid из примера выше:
# Путь будет [(0,0), (0,1), (1,1), (1,2), (2,2)]
```

**Объяснение:** Идем от конца к началу, выбирая клетки с максимальными значениями.

---

### Итог:
Динамическое программирование позволяет решать задачи оптимально, избегая повторных вычислений. Ключ — правильно определить состояние и формулу перехода. Практикуйтесь на задачах, чтобы развить интуицию!
